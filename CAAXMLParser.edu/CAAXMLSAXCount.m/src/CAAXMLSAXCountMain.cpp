
// COPYRIGHT DASSAULT SYSTEMES 2002

//=============================================================================
//
// This program prints statistics regarding the number of occurrences of
// various XML constructs in an XML document.
//
//  Illustrates:
//     1 - How to instantiate a SAX parser
//     2 - How to set custom document and a error handlers for the SAX parser 
//     3 - How to implement a custom document and a custom error handler
//    
//=============================================================================

// C++ Standard library
#include <iostream.h>

// Local Framework
#include "CAAXMLSAXCountDocHandler.h" // To handle document events generated by the SAX parser
#include "CAAXMLSAXCountErrHandler.h" // To handle error events generated by the SAX parser

// XMLParser Framework
#include "CATIXMLSAXFactory.h"       // To create the SAX objects
#include "CATISAXParser.h"           // To parse XML entities
#include "CATISAXDocumentHandler.h"  // To react the SAX document events
#include "CATISAXErrorHandler.h"     // To react the SAX error events

// System Framework
#include "CATListOfCATUnicodeString.h" // To specify options to the parser
#include "CATBoolean.h"                // V5 boolean definition
#include "CATError.h"                  // V5 error handling functions

int main(int argc, char ** argv) {

	// Make sure the input parameters are correct, otherwise display
	// the usage message.
	if (! ((argc == 2) || ((argc == 3) && strcmp(argv[1], "-v") == 0))) {
		cerr << "Usage: CAAXMLSAXCount [-v] <filepath>" << endl;
		return 1;
	}

	// The name of the file to parse
	CATUnicodeString filePath;

	// Step 3
	// Instantiate the factory. The factory knows how to create all the
	// SAX objects pertaining to a specific implementation of the
	// CAA XMLParser SAX API
	CATIXMLSAXFactory_var factory;
	HRESULT hr = ::CreateCATIXMLSAXFactory(factory);
	if (SUCCEEDED(hr) && (factory != NULL_var)) {

		// Step 4
		// Prepare the options to pass to the parser. The parser receives
		// its options in the form of (optionName, optionValue) pairs
		CATListOfCATUnicodeString options;
		CATListOfCATUnicodeString optionValues;

		// Test if the user has specified the -v option (for validating parser)
		options.Append("CATDoValidation");
		CATBoolean isValidating = (argc == 3);
		if (isValidating) {
			optionValues.Append("true");
			filePath = argv[2];
		} else {
			optionValues.Append("false");
			filePath = argv[1];
		}

		// Create a SAX parser
		CATISAXParser_var parser;
		hr = factory->CreateParser(parser, options, optionValues);
		if (SUCCEEDED(hr) && (parser != NULL_var)) {

			// Step 5
			// Customize the parser by specifying SAX handlers.
			// SAX handlers are custom objects, which will receive parser events
			// and act upon them

			// Instantiate our custom SAX document handler. It will catch
			// events such as document start, element start, XML characters...
			CAAXMLSAXCountDocHandler *docHandlerImpl = new CAAXMLSAXCountDocHandler();

			// Get a V5 handle on the SAX handler
			CATISAXDocumentHandler_var docHandler = docHandlerImpl;

			// The parser will manage the handler from then on.
			// We can remove any reference on it. 
			docHandlerImpl->Release();
			docHandlerImpl = NULL;

			// Do the same thing for the error handler. It will be
			// invoked if the parser detects abnormal input.
			
			CAAXMLSAXCountErrHandler *errHandlerImpl = new CAAXMLSAXCountErrHandler();
			CATISAXErrorHandler_var errHandler = errHandlerImpl;
			errHandlerImpl->Release();
			errHandlerImpl = NULL;

			// Register the SAX handlers with the parser
			hr = parser->SetDocumentHandler(docHandler);
			if (SUCCEEDED(hr)) {
				
				hr = parser->SetErrorHandler(errHandler);
				if (SUCCEEDED(hr)) {

					// Step 6
					// Parse the file path specified in the command line.
					hr = parser->Parse(filePath);
				}
			}
		}
	}

	// Step 7
	// Print error messages if an error has occurred
	if (FAILED(hr)) {
		CATError* error = CATError::CATGetLastError(hr);
		if (error != NULL) {
			cerr << "CAAXMLSAXCount " << filePath.ConvertToChar() << " has failed:" << endl << error->GetNLSMessage().ConvertToChar() << endl;
			error->Release();
			error = NULL;
		}
		CATError::CATCleanLastError();
		return 1;
	}
	return 0;
}

