
// COPYRIGHT DASSAULT SYSTEMES 2002

//=============================================================================
//
// This program parses XML files whose DTDs are stored in a database. For
// simplicity's sake, the database is just a directory somewhere on the disk
// The system ID of the DTDs must begin with the string: "sql://"
//
//  Illustrates:
//     1 - How to instantiate a SAX parser
//     2 - How to set a custom entity resolver and a error handler for the SAX parser 
//     3 - How to implement a custom entity resolver and a custom error handler
//    
//=============================================================================

// C++ Standard library
#include <iostream.h>

// Local Framework
#include "CAAXMLSAXResolverHandlers.h" // To events generated by the SAX parser

// XMLParser Framework
#include "CATIXMLSAXFactory.h"       // To create the SAX objects
#include "CATISAXParser.h"           // To parse XML entities
#include "CATISAXEntityResolver.h"   // To react the SAX entity events
#include "CATISAXErrorHandler.h"     // To react the SAX error events

// System Framework
#include "CATError.h"                  // V5 error handling functions

int main(int argc, char ** argv) {

	// Make sure the input parameters are correct, otherwise display
	// the usage message.
	if (argc != 3) {
		cerr << "Usage: CAAXMLSAXResolver <databasedir> <filepath>" << endl;
		return 1;
	}

	// The name of the database directory and file to parse
	CATUnicodeString databaseDir = argv[1];
	CATUnicodeString filePath = argv[2];

	// Step 2
	// Instantiate the factory. The factory knows how to create all the
	// SAX objects pertaining to a specific implementation of the
	// CAA XMLParser SAX API
	CATIXMLSAXFactory_var factory;
	HRESULT hr = ::CreateCATIXMLSAXFactory(factory);
	if (SUCCEEDED(hr) && (factory != NULL_var)) {

		// Step 3
		// Create a SAX parser
		CATISAXParser_var parser;
		hr = factory->CreateParser(parser);
		if (SUCCEEDED(hr) && (parser != NULL_var)) {

			// Step 4
			// Customize the parser by specifying SAX handlers.
			// SAX handlers are custom objects, which will receive parser events
			// and act upon them

			// Instantiate our custom SAX entity handler and error handler.
			// (the same class implements both event interfaces)
			// It will be invoked by the SAX parser any time:
			// + it come across an unresolved entity reference
			// + it detects abnormal input
			CAAXMLSAXResolverHandlers *handlersImpl = new CAAXMLSAXResolverHandlers(databaseDir);

			// Get V5 handles on the SAX handlers
			CATISAXEntityResolver_var entityHandler = handlersImpl;
			CATISAXErrorHandler_var errHandler = handlersImpl;

			// The V5 handles will manage the handler from then on.
			// We can remove any reference on it. 
			handlersImpl->Release();
			handlersImpl = NULL;

			if (SUCCEEDED(hr) && (errHandler != NULL_var)) {
				// Pass the SAX handlers to the parser
				hr = parser->SetEntityResolver(entityHandler);
				if (SUCCEEDED(hr)) {
					hr = parser->SetErrorHandler(errHandler);		
					if (SUCCEEDED(hr)) {

						// Step 4
						// Parse the file path specified in the command line.
						hr = parser->Parse(filePath);
					}
				}
			}
		}
	}

	// Step 5
	// Print error messages if an error has occurred
	if (FAILED(hr)) {
		CATError* error = CATError::CATGetLastError(hr);
		if (error != NULL) {
			cerr << "CAAXMLSAXResolver " << filePath.ConvertToChar() << " has failed:" << endl << error->GetNLSMessage().ConvertToChar() << endl;
			error->Release();
			error = NULL;
		}
		CATError::CATCleanLastError();
		return 1;
	}
	return 0;
}

