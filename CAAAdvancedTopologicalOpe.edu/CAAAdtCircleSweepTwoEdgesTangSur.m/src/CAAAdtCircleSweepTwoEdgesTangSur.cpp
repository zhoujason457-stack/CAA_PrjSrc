/**
* @quickReview CRE 03:10:17
*/
//=============================================================================
// COPYRIGHT DASSAULT SYSTEMES  2002
//
// Sample code for : Geometric Modeler
// Mission         : Explains how to create a circle sweep with two guides and 
//                   a tangency surface - one of the guide must lie on the surface
//                   to which the sweep is tangent.
//           
// Type            : Batch program
// Inputs          : None
// Outputs         : Return codes (if not null, the model is not saved)
//                   0- OK
//                   1- Null pointer
//
// Main steps        1- Create the geometry factory and other preliminary operations
//                   2- Create the guides
//                   3- Create the tangency surface
//                   4- Project one of the guide on the tangency surface
//                   5- Create the sweep operator 
//                   6- Clean the no longer wanted objects 
//                   7- Write the model and close the container  
//
// How to run it   : CAAAdtCircleSweepTwoEdgesTangSur    // to run whithout storing the NCGM file
//                   CAAAdtCircleSweepTwoEdgesTangSur file.NCGM // to run and store the result 
//                   in file.NCGM     
//==================================================================

#include <iostream.h>
#include <iomanip.h>
#include "fstream.h"

// Mathematics
#include "CATMathAxis.h"                 // Math axis creation
#include "CATMathPlane.h"                // Math plane
#include "CATMathPoint.h"                // Mathematical point

// Advanced Mathematics
#include "CATMathSetOfPointsND.h"        // Creation of a set of points
#include "CATSoftwareConfiguration.h"

// GeometricObjects
#include "CATGeoFactory.h"               // Geometry factory
#include "CATCGMContainerMngt.h"         // Management of the geometry factory
#include "CATSplineCurve.h"              // Spline creation
#include "CATCompositeLaw.h"             // Composite law creation
#include "CATCrvLimits.h"                // Curve limits

// TopologicalOperators
#include "CATTopPrism.h"                 // Prism (extrude) operator
#include "CATTopWire.h"                  // Wire operator
#include "CATHybProject.h"               // Projection operator
#include "CATCreateTopProject.h"         // To create the projection operator

// AdvancedTopologicalOpe
#include "CATFrFTopologicalSweep.h"      // Sweep operator
#include "CreateFrFTopologicalSweep.h"   // To create the sweep operator

// NewTopologicalObjects
#include "CATBody.h"                     // Body
#include "ListPOfCATBody.h"              // List of bodies


// ---------------------------------------------------------------------------
int main(int    iArgc,   // Number of arguments (0) or (1) 
         char** iArgv)   // Path to the *.NCGM document generated by this program
{
    int rc=0;
    if(2<iArgc) return (1);
    
    char *pFileName = 0;
    int  toStore = 0;
    if (2==iArgc) 
    {
        toStore = 1; 
        pFileName = iArgv[1];
    }
    
    //----------------------------------------------------------------------------
    // 1 - Preliminary operations
    //----------------------------------------------------------------------------
    //
    // a - Factory 
    //
    CATGeoFactory* piGeomFactory = ::CATCreateCGMContainer() ;
    if (NULL==piGeomFactory) return (1);
    cout << "starting " << endl;
    
    // b - Configuration
    //
    CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();
    CATTopData topdata(pConfig, NULL);
    
    // -----------------------------------------------------------------------------
    // 2 - Create the guides (2 splines)
    // -----------------------------------------------------------------------------
    
    // ---- (a) Specify the CATMathSetOfPointsND to be used to create 
    //          the splines
    //
    CATMathSetOfPointsND pointSet1(3,3);  // Spline 1
    CATMathSetOfPointsND pointSet2(3,3);  // Spline 2
    
    // ---- (b) Specify the points to be used for the splines
    //
    double Point1[3]={ 0.0,  0.0,  0.0} ;
    double Point2[3]={ 0.0, 41.0,  3.0} ;
    double Point3[3]={ 0.0, 93.0, -6.0} ;
    double Point4[3]={10.0,  0.0,  0.0} ;
    double Point5[3]={10.0, 44.0, -3.0} ;
    double Point6[3]={10.0, 98.0, -2.0} ;
    
    // ---- (c) Create the spline 1
    //
    pointSet1.AddPoint(Point1); // Point1
    pointSet1.AddPoint(Point2); // Point2
    pointSet1.AddPoint(Point3); // Point3
    
    double param1[3];
    param1[0] = 0.;
    param1[1] = 1.;
    param1[2] = 2.;
    
    CATSplineCurve * piSpline1 = 
        piGeomFactory->CreateSplineCurve(&pointSet1,0,1,2,param1);
    if (NULL==piSpline1)
    {
        ::CATCloseCGMContainer(piGeomFactory);
        return (1);
    }
    CATCurve * piCurve1 = (CATCurve*)piSpline1;
    
    // ---- (d) Create the spline 2
    //
    pointSet2.AddPoint(Point4); //Point4
    pointSet2.AddPoint(Point5); //Point5
    pointSet2.AddPoint(Point6); //Point6	
    
    double param2[3];
    param2[0] = 0.;
    param2[1] = 1.;
    param2[2] = 2.;
    
    CATSplineCurve * piSpline2 = piGeomFactory->CreateSplineCurve(&pointSet2,0,1,2,param2);
    if (NULL==piSpline2)
    {
        ::CATCloseCGMContainer(piGeomFactory);
        return (1);
    }
    CATCurve * piCurve2 = (CATCurve*)piSpline2;
    
    // ---- (e) Create the wire 1
    //
    CATLONG32 nbcurve1 = 1;
    CATCurve * ListOfCurves1;
    
    ListOfCurves1 = piCurve1;
    CATCrvLimits CurLim1[1];
    CATOrientation Orient1[1]={1};
    ListOfCurves1->GetLimits(CurLim1[0]);
    CATTopWire * pWire1 = CATCreateTopWire(piGeomFactory, 
        &topdata,
        1,
        &ListOfCurves1,
        CurLim1,
        Orient1);
    if (NULL==pWire1)
    {
        ::CATCloseCGMContainer(piGeomFactory);
        return (1);
    }
    
    pWire1->Run();
    
    CATBody * pWireBody1 = pWire1->GetResult();
    if (NULL==pWireBody1)
    {
        cout << "No valid result for wire1 " << endl;
        ::CATCloseCGMContainer(piGeomFactory);
        return (1);
    }   
    delete pWire1;
    pWire1 = NULL;
    
    // ---- (f) Create the wire 2
    //
    CATLONG32 nbcurve2 = 1;
    CATCurve * ListOfCurves2;
    
    ListOfCurves2 = piCurve2;
    CATCrvLimits CurLim2[1];
    CATOrientation Orient2[1]={1};
    ListOfCurves2->GetLimits(CurLim2[0]);
    CATTopWire * pWire2 = CATCreateTopWire(piGeomFactory, 
        &topdata,
        1,
        &ListOfCurves2,
        CurLim2,
        Orient2);
    if (NULL==pWire2)
    {
        ::CATCloseCGMContainer(piGeomFactory);
        return (1);
    }
    
    pWire2->Run();
    
    CATBody * pWireBody2 = pWire2->GetResult();
    if (NULL==pWireBody2)
    {
        cout << "No valid result for wire 2" << endl;
        ::CATCloseCGMContainer(piGeomFactory);
        return (1);
    }   
    delete pWire2;
    pWire2 = NULL;
    
    // -----------------------------------------------------------------------------
    // 3 - Create the surface
    // -----------------------------------------------------------------------------
    
    CATMathDirection yDir(0.,0.,1.);
    
    CATTopPrism * pPrismOpe = ::CATCreateTopPrism(piGeomFactory, 
        &topdata,
        pWireBody1,
        &yDir,
        50,-50);

    if (NULL==pPrismOpe)
    {
        ::CATCloseCGMContainer(piGeomFactory);
        return (1);
    }
    

    pPrismOpe->Run();
    
    CATBody * pPBody = pPrismOpe->GetResult();
    if (NULL==pPBody)
    {
        cout << "Problem when creating the CATTopPrism " << endl;
        ::CATCloseCGMContainer(piGeomFactory);
        return (1);
    }
    
    delete pPrismOpe;
    pPrismOpe = NULL;
    
    // -----------------------------------------------------------------------------
    // 4 - Create the projection (one of the guide must have a link with the 
    //     tangency surface)
    // -----------------------------------------------------------------------------
    
    CATHybProject * pProjOpe = NULL;
    pProjOpe = ::CATCreateTopProject(piGeomFactory,
        &topdata,
        pWireBody1,
        pPBody);
    if (NULL== pProjOpe)
    {
        ::CATCloseCGMContainer(piGeomFactory);
        return (1);
    }
    pProjOpe->Run();
    CATBody * pBodyProj = pProjOpe->GetResult();
    
    delete pProjOpe;
    pProjOpe = NULL;

    // -----------------------------------------------------------------------------
    // 5 - Create the sweep 
    // -----------------------------------------------------------------------------
    
    CATLISTP(CATGeometry) guides ;
    CATGeometry * pGuideGeom2 = (CATGeometry*)pWireBody2 ;
    CATGeometry * pGuideGeom1 = (CATGeometry*)pBodyProj ;
    
    guides.Append(pGuideGeom2);
    guides.Append(pGuideGeom1);
    
    // (a) - Create the sweep operator
    //
    CATFrFTopologicalSweep * pSweepOpe = CATCreateFrFTopologicalCircleSweep(piGeomFactory, 
        &topdata, &guides);
    if (NULL==pSweepOpe)
    {
        cout << "Pb when creating the sweep operator " << endl;
        ::CATCloseCGMContainer(piGeomFactory);
        return (1);
    }
    
    // (b) - Set the parameters
    //
    //       1 - Define the composite law for tangency 
    //
    CATCompositeLaw * pCompLaw = NULL;

    //       2 - Specify the slope. 
    //           When the angle is 0, the sweep to be generated is tangent to 
    //           the reference element. The rank specified is
    //           the rank of the guide which is a projection on the surface 
    //           in the CATLISTP(CATGeometry) list of guides.
    //
    CATGeometry * referenceElement = (CATGeometry *)pPBody;
    int rank = 2;
    pSweepOpe->SetLimitGuideSlopeCondition(rank, referenceElement,pCompLaw );
     
    //       3 - Specify the solution to be kept
    //
    CATLONG32 solution = 2;
    pSweepOpe ->SetSolutionChoice(solution);

    //       4 - Check the input data for the required 
    //           type of sweep
    //
    cout << "Case Number " << pSweepOpe->ValidateCaseNumber(6) << endl;
    if (6 != pSweepOpe->ValidateCaseNumber(6))
    {
        cout << "Probleme with the input data " << endl;
        ::CATCloseCGMContainer(piGeomFactory);
        return (1);
    }
    
    // (c) - Run the operator
    //
    pSweepOpe -> Run();

    // (d) - Retrieve the resulting body
    //
    CATBody * pBodySweepCircle  = pSweepOpe->GetResult();
    
    // (e) - Delete the operator
    //
    delete pSweepOpe;
    pSweepOpe = NULL;
    
    // -----------------------------------------------------------------------------
    // 6 - Cleaning operations
    // -----------------------------------------------------------------------------
    
    piGeomFactory->Remove(pBodyProj);
    piGeomFactory->Remove(pPBody);
    piGeomFactory->Remove(pWireBody1);
    piGeomFactory->Remove(pWireBody2);

    pConfig->Release();
    
    //----------------------------------------------------------------------------
    // 7 - Save the model
    //----------------------------------------------------------------------------
    
    if(1==toStore)
    {
        cout << "Writing the model" << endl;
#ifdef _WINDOWS_SOURCE
        ofstream filetowrite(pFileName, ios::binary ) ;
#else
        ofstream filetowrite(pFileName,ios::out,filebuf::openprot) ;
#endif
        
        ::CATSaveCGMContainer(piGeomFactory,filetowrite);
        filetowrite.close();
    }	
    
    ::CATCloseCGMContainer(piGeomFactory);
    return (rc);
}


