// COPYRIGHT Dassault Systemes 2002
//===================================================================
//
// CAAEAniTensorExplicit.cpp
// Header definition of CAAEAniTensorExplicit
//
//===================================================================
//
// Usage notes:
//
//===================================================================
//
//  Dec 2002  Creation: Code generated by the CAA wizard  
//===================================================================
#include "CAAEAniTensorExplicit.h"

// CATAnalysisInterfaces prereq 
#include "CATISamAnalysisModel.h"
#include "CATISamBasicComponent.h"
#include "CATISamAnalysisEntity.h"
#include "CATISamAnalysisSupport.h"
#include "CATISamExplicit.h"
#include "CATISamAnalysisSupport.h"

// ObjectSpecsModeler prereq
#include "CATISpecObject.h"

// CATAnalysisBase prereq
#include "CATISamGroup.h"
#include "CATLISTP_CATAnalysisEntityCollector.h"
#include "CATAnalysisEntityCollector.h"
#include "CATAnalysisExplicitEntity.h"
#include "CATAnalysisExplicitCharac.h"
#include "CATAnalysisExplicitListUsr.h"
#include "CATAnalysisExplicitRulesData.h"


CATImplementClass( CAAEAniTensorExplicit,CodeExtension,CATBaseUnknown,
				   STRUCTURAL_ANISymetricalTensorEntityTst);
 
// Tie the implementation to its interface
// ---------------------------------------
#include "TIE_CATISamExplicitation.h"
TIE_CATISamExplicitation(CAAEAniTensorExplicit);


//-----------------------------------------------------------------------------
// CAAEAniTensorExplicit : constructor
//-----------------------------------------------------------------------------
CAAEAniTensorExplicit::CAAEAniTensorExplicit():
CATBaseUnknown()
{
}

//-----------------------------------------------------------------------------
// CAAEAniTensorExplicit : destructor
//-----------------------------------------------------------------------------
CAAEAniTensorExplicit::~CAAEAniTensorExplicit()
{
}

//-----------------------------------------------------------------------------
// Implements CATISamExplicit::TranslateToFieldModel
//-----------------------------------------------------------------------------
HRESULT CAAEAniTensorExplicit::TranslateToFieldModel(CATISpecObject* iFeatToTranslate, 
													CATISamAnalysisModel* iFEMModel, 
													CATAnalysisExplicitListUsr& iOldExplObjects, 
													CATAnalysisExplicitListUsr& oNewExplObjects)
{
	// We check if the iFeatToTranslate is not null
	if ( ! iFeatToTranslate ) return E_FAIL;
	
	// ***
	// *** 1st Step : We remove the current explicitation if it has already been existed ***
	// ***
	CATString Position("NODE");
	CATISamExplicit_var SpecExpli(iFeatToTranslate);
	if (! SpecExpli) return E_NOINTERFACE;

	// retrieve the field model
	CATAnalysisExplicitModel* ExplicitModel = SpecExpli -> GetExplicitModel();
	if (!ExplicitModel) return E_FAIL;


	HRESULT HR;
	// Creation of the needed lists for the explicitation
	CATAnalysisExplicitListUsr		ContainingData,	AxisList;
	ContainingData.CreateList(ExplicitModel);
	AxisList.CreateList(ExplicitModel);

	HR = SpecExpli -> GetContainingData(iOldExplObjects,ContainingData);
	if (FAILED(HR)) return HR;
	if ( *(ContainingData.First()) == NULL_exp ) return E_FAIL;
	
	// ***
	// *** 2nd Step : We get the explicit physical type string.
	// ***

	CATString aPhysicalType = SpecExpli -> GetPhysicalType();
	

	// ***
	// *** 3rd Step : We get the definition of DOF fixation.
	// ***
	
	CATISamAnalysisEntity_var AnalysisEntity(iFeatToTranslate);
	if(!AnalysisEntity)	return E_HANDLE;
	
	CATLISTV(CATBaseUnknown_var) *BasCompList = NULL;
	CATISamBasicComponent_var aBasComp;

	// We get the Basic Component dedicated to the DOF description of
	// the restrain. 
	int DOFDescVal=0;
	HR = AnalysisEntity->GetBasicComponents(BasCompList,"SAMDOFBinary");
	if (SUCCEEDED(HR) && NULL!=BasCompList)
	{
		aBasComp = (*BasCompList)[1];		
		if (!aBasComp) 			HR = E_FAIL;
	
		if (SUCCEEDED(HR))
			HR = aBasComp->GetIntegerValue(DOFDescVal);		
	}
	if (BasCompList) 	delete BasCompList;	BasCompList = NULL;
	

	// ***
	// *** 4th Step : We look for the support entities on which we have to work
	// ***
			
	CATISamAnalysisSupport_var Support(iFeatToTranslate);
	if (!Support) return E_FAIL;

	CATLISTV(CATBaseUnknown_var) SupportsList;
	HR = Support->GetEntities(SupportsList,IID_CATBaseUnknown);
	if (FAILED(HR)) return E_FAIL;


	// ***
	// *** 5th Step : We get the entity collector 
	// ***
 
	int												i(0);
	int	size = SupportsList.Size();
	if(!size) return E_FAIL;

	CATISamGroup_var					Group;
	const	CATAnalysisEntityCollector*	EntityCollector	= NULL;
	CATSamValue							SamValue		= CATSamValueNode;
	const	CATSamPhysicalType*			oElemTypes		= NULL;
	int									Number(0);

	CATLISTP(CATAnalysisEntityCollector) ListCollectors;
  
	for (i=1 ; i <= size ;i++)
	{
		Group = SupportsList[i];
		if (!Group) return E_FAIL;

		HR = Group->GetContent(SamValue,Position,EntityCollector);
		if (FAILED(HR) ) return E_FAIL;
		if (EntityCollector)
		{
			ListCollectors.Append((CATAnalysisEntityCollector*)EntityCollector);
			EntityCollector=NULL;
		}	
		else 
			return E_FAIL;
	}


  	// ***
	// *** 6th Step : We create the explicit entity and the explicit charateristic collector
	// ***

	CATSamPhysicalType EntPhysTypeNb,CharacPhysTypeNb;
	CATAnalysisExplicitEntity ExpEntity;
	CATAnalysisExplicitCharac ExpCharac;
	short characValue(0);
	size = ListCollectors.Size();
	const CATAnalysisExplicitRulesData *pRulesData = NULL;
	pRulesData = ExplicitModel->GetRulesData();
	if(!pRulesData) return E_FAIL;

	pRulesData->GetPhysicalTypeNumber(aPhysicalType,EntPhysTypeNb);
	pRulesData->GetPhysicalTypeNumber("DEGREES_OF_FREEDOM",CharacPhysTypeNb);

	characValue = DOFDescVal;
  
    for(i=1 ; i <= size ; i++)
    {
		ExpEntity.CreateEntity(ExplicitModel,EntPhysTypeNb);
		ExpCharac.CreateCharac(ExpEntity,CharacPhysTypeNb);
		ExpCharac.SetValues(characValue);
		if (ExpEntity != NULL_exp) 
			oNewExplObjects +=ExpEntity;
    }


	// ***
	// *** 7th Step : We apply the entity on the support.
	// ***

	const CATSamExplicitPtr * ApplyTo=NULL;
	const int* ApplyNumber=NULL;
	int NbEntity = oNewExplObjects.GetLength();
	if (!NbEntity) return E_FAIL;

	ExpEntity = *(oNewExplObjects.First()) ;
	CATSamPosition  ApplyPosition;

	//retrieve the collector information
	CATString Pos;
	for(i=1 ; i <= size; i++)
	{
		EntityCollector = ListCollectors[i];
		if(!EntityCollector) return E_FAIL;

		HR=EntityCollector->GetDefinition(SamValue, Pos);
		if(FAILED(HR)) return HR;
		HR = CATSamIdentityEnum(Pos.CastToCharPtr(), ApplyPosition);
	
		//retrieve the explicit pointers
		HR=EntityCollector -> GetExplicitPointers(Number, ApplyTo, ApplyNumber);
		if(FAILED(HR)) return HR;
		if (ApplyNumber) 
			HR = ExpEntity.ApplyTo(Number, ApplyTo, ApplyPosition, ApplyNumber);
		else             
			HR = ExpEntity.ApplyTo(Number, ApplyTo, ApplyPosition);
		if(FAILED(HR)) return HR;

		ApplyTo=NULL;
		EntityCollector=NULL;
		if (NbEntity == size) ExpEntity = *(oNewExplObjects.Next()) ;
	}


	// ***
	// *** 8th Step : We update the new explicit data under the current containing data
	// ***

	HR = SpecExpli -> UpdateExplicitList(iOldExplObjects,ContainingData,oNewExplObjects);
	if (ContainingData != NULL_exp ) ContainingData.Delete();

	return HR;
}

