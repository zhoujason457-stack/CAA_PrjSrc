/**
* @quickReview CRE 03:10:17
*/
//=============================================================================
//
// COPYRIGHT DASSAULT SYSTEMES  2002
//
// Sample code for : FreeFormOperators
// Mission         : Use of the FreeFormOperators framework
//
// Type            : Batch program
// Inputs          : None
// Outputs         : Return Codes (if not null, the model is not saved)
//                    0- OK
//                    1- Null pointer or other trouble
//
// Coding steps    :  1- Create a 3 degree Nurbs
//                    2- Increase the Nurbs degree (3->4)
//                    3- Retrieve the Nurbs limits
//                    4- Deletion of the  operator
//                    5- Writing the model and closing the geometric container
//                   
//
// How to run it   : CAAFrfInDegree           // to run without storing the NCGM file
//                   CAAFrfInDegree file.NCGM // to run and store the result in file.NCGM                       
//=============================================================================

#include <iostream.h>
#include <iomanip.h>
#include <fstream.h>

// Mathematics
#include "CATMath.h"
#include "CATMathPoint.h" 

// GeometricObjects
#include "CATGeoFactory.h"               // Geometry factory
#include "CATCGMContainerMngt.h"         // Management of the geometry factory
#include "CATCrvParam.h" 
#include "CATCrvLimits.h" 
#include "CATCrvEvalLocal.h" 
#include "CATCartesianPoint.h"           // Geometric Cartesian point
#include "CATKnotVector.h" 
#include "CATNurbsCurve.h"               // NURBS curve

// FreeFormOperators
#include "CATCrvDegreeModification.h"    // Modify the degree of a curve
#include "CreateCrvDegreeModification.h" // To create the CATCrvDegreeModification operator


//------------------------------------------------------------------------------
int main(int    iArgc,   // Number of arguments (0) or (1) 
         char** iArgv)   // Path to the *.NCGM document generated by this program
{
    int rc=0;
    if(2<iArgc) return (1);
    
    char *pFileName = 0;
    int  toStore = 0;
    if (2==iArgc) 
    {
        toStore = 1; 
        pFileName = iArgv[1];
    }
    
    //----------------------------------------------------------------------------
    // 1-Initialize the factory 
    //----------------------------------------------------------------------------
    
    CATGeoFactory* piGeomFactory = ::CATCreateCGMContainer() ;
    if (NULL==piGeomFactory) return (1);
    
    //----------------------------------------------------------------------------
    // 2 - Create a degree 3 curve
    //----------------------------------------------------------------------------
    
    // (a) ---- Create the knot vector
    // 
	const CATLONG32 nbknots=4;
	double aKnots[nbknots];
	aKnots[0]=0;
	aKnots[1]=2;
	aKnots[2]=8;
	aKnots[3]=9;
	CATLONG32 isPeriodic=0;
	CATLONG32 continuity=2;
	CATKnotVector NonUniform(isPeriodic,nbknots,aKnots,continuity);
    
    // (b) ---- Create the control points
    // 
    CATMathSetOfPoints poles(6);
    poles.SetPoint(CATMathPoint(-10.,10.,15.),0);
    poles.SetPoint(CATMathPoint(+15.,15.,17.),1);
    poles.SetPoint(CATMathPoint(+25.,15.,20.),2);
    poles.SetPoint(CATMathPoint(+13.,10.,30.),3);
    poles.SetPoint(CATMathPoint(+22.,10.,40.),4);
    poles.SetPoint(CATMathPoint(+21.,10.,50.),5);
	
    // (c) ---- Create the Nurbs
    // 	
    CATLONG32 isRational=0;
    double * aWeights=NULL;
    CATNurbsCurve * curveToBeInverted = piGeomFactory->
        CATCreateNurbsCurve(NonUniform,isRational,poles,aWeights);
    if (NULL==curveToBeInverted)
    {
        ::CATCloseCGMContainer(piGeomFactory);
        return (1);
    }	
    cout << "nurbs created" << endl;
    //----------------------------------------------------------------------------
    // 3 - Modify the Nurbs degree 
    //----------------------------------------------------------------------------
    //
    const CATLONG32 targetDegree = 4 ;
    CATCrvDegreeModification * degreeModifOpe =::CreateCrvDegreeModification(
        piGeomFactory,
        curveToBeInverted,
        targetDegree);

    if (NULL==degreeModifOpe)
    {
        ::CATCloseCGMContainer(piGeomFactory);
        return (1);
    }	

    delete degreeModifOpe; 
    degreeModifOpe = NULL;

    //----------------------------------------------------------------------------
    // 4 - Get the current limits 
    //----------------------------------------------------------------------------
    //
    CATCrvParam startParam;
    CATCrvParam endParam;
    CATCrvEvalLocal evalResultS;
    CATCrvEvalLocal evalResultE;
    
    curveToBeInverted->GetStartLimit(startParam); 
    curveToBeInverted->GetEndLimit(endParam);
    curveToBeInverted->Eval(startParam, CATCrvEvalCommand::EvalPoint, evalResultS) ;
    CATMathPoint mathPointS;
    evalResultS.GetPoint(mathPointS);
    cout << "Start Point " ;
    cout << mathPointS.GetX() << ", "  ;
    cout << mathPointS.GetY() << ", "  ;
    cout << mathPointS.GetZ() << endl;
    
    curveToBeInverted->Eval(endParam, CATCrvEvalCommand::EvalPoint, evalResultE) ;
    CATMathPoint mathPointE;
    evalResultE.GetPoint(mathPointE);
    cout << "End Point " ;
    cout << mathPointE.GetX() << ", " ;
    cout << mathPointE.GetY() << ", " ;
    cout << mathPointE.GetZ() << endl;
    
    //----------------------------------------------------------------------------
    // 5 - Invert 
    //----------------------------------------------------------------------------
    //
    // (a) --- Retrieve the characteristics of the 3 DEG curve
    // 
    CATKnotVector KV4DEG (*(curveToBeInverted->GetKnotVector()));

    const double * Knots4DEG = NULL; 

    KV4DEG.GetKnots(Knots4DEG);

    CATLONG32 NbKnots4DEG = KV4DEG.GetNumberOfKnots();
    CATLONG32 NbOfCPs4DEG = KV4DEG.GetNumberOfControlPoints();
    CATLONG32 NewNbArcs4DEG = KV4DEG.GetNumberOfArcs();
    CATLONG32 NewDegree4DEG = KV4DEG.GetDegree();
    cout << "New number of knots: " << NbKnots4DEG << endl;
    cout << "New number of control points : " << NbOfCPs4DEG << endl;
    cout << "New number of arcs:  " << NewNbArcs4DEG << endl;
    cout << "New degree        :  " << NewDegree4DEG << endl;

    cout << "values of DEG 4 knots before inversion" << endl;
    for (int k=0; k<NbKnots4DEG; k++)
    {
        cout << Knots4DEG[k] << endl;
    }
       
    // (b) --- Pole inversion
    //
    double Coord13D[3] , Coord23D[3];
    CATLONG32 Pivot=NbOfCPs4DEG/2;
    CATMathPoint  * tabOfCPs = new CATMathPoint [NbOfCPs4DEG];

    // Fill in tabOfCPs with the old control points
    //
    CATLONG32 i = 0;
for (; i<NbOfCPs4DEG; i++)
    {
        curveToBeInverted->GetOneControlPoint(i+1, tabOfCPs[i]);
    }
     cout << "CTRL PTS BEFORE INVERSION" << endl;
    for ( i=0; i<NbOfCPs4DEG; i++)
    {
        cout << "X " << tabOfCPs[i].GetX() << " " ;
        cout << "Y " << tabOfCPs[i].GetY() << " " ;
        cout << "Z " << tabOfCPs[i].GetZ() << " " << endl;
    }

    // Invert the control points in tabOfCPs
    //
    for (i = 0; i<Pivot; i++)
    {
        tabOfCPs[i].GetCoord(Coord13D);
        tabOfCPs[(NbOfCPs4DEG-i-1)].GetCoord(Coord23D);
        tabOfCPs[i].SetCoord(Coord23D);
        tabOfCPs[(NbOfCPs4DEG-i-1)].SetCoord(Coord13D);
    }
   
    cout << "CTRL PTS AFTER INVERSION" << endl;
    for ( i=0; i<NbOfCPs4DEG; i++)
    {
        cout << "X " << tabOfCPs[i].GetX() << " " ;
        cout << "Y " << tabOfCPs[i].GetY() << " " ;
        cout << "Z " << tabOfCPs[i].GetZ() << " " << endl;
    }

    // (c) --- Creation of a CATMathSetOfPoints with inverted poles
    //
    CATMathSetOfPoints vertices4DEG(NbOfCPs4DEG);
    for ( i=0; i<NbOfCPs4DEG; i++)
    {
        vertices4DEG.SetPoint(tabOfCPs[i],i);
    }

    // (d) --- Invert the weights if rational curve
    // 
    if (isRational)
    {
        for (i = 0; i<Pivot; i++) 
            CATSwap(aWeights[(NbOfCPs4DEG-i-1)],aWeights[i]);
    }
    
    // (e) --- Update the knots
    //
    double * invertedKnots = new double [NbKnots4DEG];
    invertedKnots[0] = Knots4DEG[0];
    cout << "inverted knots" << endl;
    for ( int j=1; j<NbKnots4DEG; j++)
    {
        invertedKnots[j] = invertedKnots[j-1]+(Knots4DEG[NbKnots4DEG-j]-Knots4DEG[NbKnots4DEG-j-1]);
        cout << invertedKnots[j] << endl;
    }
   
    // (f) --- Invert the multiplicities
    //
    CATLONG32 * newMultiplicities = new CATLONG32 [NbKnots4DEG];
    for (i=0; i<NbKnots4DEG; i++) 
    {
      newMultiplicities[i] = KV4DEG.GetKnotMultiplicity(NbKnots4DEG-i);
      cout << newMultiplicities[i] << endl ;
    }
    
    //----------------------------------------
    // 6 - Update the Nurbs data 
    //----------------------------------------
	  CATLONG32 IsPeriodic= 0;
    KV4DEG.SetNonUniformKnotVector(NewDegree4DEG,IsPeriodic,
        NbKnots4DEG,invertedKnots, newMultiplicities);
   
    curveToBeInverted->SetData(KV4DEG,0,vertices4DEG,aWeights);
 
	delete [] tabOfCPs; tabOfCPs = NULL;
	delete [] invertedKnots; invertedKnots = NULL;
    delete[] newMultiplicities; newMultiplicities=NULL;
	
    //----------------------------------------------------------------------------
    // 7 - Write the model and close the container
    //----------------------------------------------------------------------------
    if(1==toStore)
    {
        cout << "Writing the model" << endl;
#ifdef _WINDOWS_SOURCE
        ofstream filetowrite(pFileName, ios::binary ) ;
#else
        ofstream filetowrite(pFileName,ios::out,filebuf::openprot) ;
#endif
        
        ::CATSaveCGMContainer(piGeomFactory,filetowrite);
        filetowrite.close();
    }	
   	
    ::CATCloseCGMContainer(piGeomFactory);
    return (rc);
}

